3.集合框架   https://www.cnblogs.com/xiaoxi/p/6089984.html
5.JVM原理：  https://blog.csdn.net/luomingkui1109/article/details/72820232
6.Eclipse常用快捷键：  http://www.runoob.com/eclipse/eclipse-shortcuts.html
7.线程：  http://www.mamicode.com/info-detail-517008.html
8.HTML+CSS：  https://blog.csdn.net/keledon/article/details/72903005 
9.Socket:   https://www.cnblogs.com/yiwangzhibujian/p/7107785.html
11.Git + GitHub  https://blog.csdn.net/qq_27099139/article/details/79966288
12.java项目编码格式  https://www.cnblogs.com/endtel/p/6837850.html
13.解决tomcat中POST/GET乱码问题  https://www.cnblogs.com/liushuncheng/p/6891307.html?utm_source=itdadao&utm_medium=referral
14.博客园java技术  http://www.cnblogs.com/xdp-gacl/tag
15.linux虚拟机移动以后IP地址无法找到 http://blog.51cto.com/alex233/1889367
16.集合 https://www.cnblogs.com/forestwolf/p/5645179.html
17.简历 https://blog.csdn.net/scgyus/article/details/79388592
18.Oracle数据库优化  https://blog.csdn.net/dayu236/article/details/52662395
19.java Context  https://blog.csdn.net/u013147600/article/details/49616427
20.Spring总体概述  https://www.cnblogs.com/ysocean/p/7466191.html#_label5
21.String类总结  https://blog.csdn.net/qq_35447305/article/details/52549559
22.Hibernate快速入门  https://blog.csdn.net/yerenyuan_pku/article/details/64209343
23.SpringMVC与Struts2区别与比较总结  https://blog.csdn.net/silenttalfrede/article/details/52950762
24.javaweb面试题  https://www.cnblogs.com/darren0415/p/6040894.html
                  https://www.cnblogs.com/think90/p/8146312.html
25.java框架面试  https://www.cnblogs.com/xuzimian/p/8603060.html

Task:
0. 反射 https://blog.csdn.net/sinat_38259539/article/details/71799078
4. Http协议



常见面试：
【1】异常的处理方式一：try/catch
       finally永远都会在catch的return前被执行，若多个catch块中的异常类型具备子父类关系，必须“子上父下”
       finally是可以信任的：经过测试，哪怕是发生了OutofMemoryError，finally块中的语句执行也能够得到保证。
       若try语句块里面有return 20; finally语句块内有 return 40; 最终返回值是40，即执行finally内的return
     异常的处理方式二：Function throws
     异常的处理方式三：throw写在方法体内
       public static void div(int a, int b){
            if(b == 0){
                throw new RuntimeException("除数不能为零");   
            }
       }
自定义异常：
  声明一个类继承一个异常类（继承Exception 该异常为编译时异常，继承RuntimeException该异常为运行时异常）
  编写构造器（通常利用构造器为 getMessage() 方法设置值）

异常处理的常用方法
  printStackTrace() : 打印异常的详细信息。
  String getMessage() : 返回异常的描述信息
【2】类的属性变量是能重写（覆盖）
class Animal{
  public int age;
}
class Dog extends Animal{
  public double age;
}

  Animal a = new Dog();
  Dog b = new Dog();  // 覆盖age属性

  a.age from class Animal
  b.age from class Dog
【3】子抽象类继承父抽象类，必须显性调用父抽象类的显性构造器
【4】重写接口中声明的方法时，需要注意以下规则：
   类在实现接口的方法时，不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制性异常。
   类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型。
   如果实现接口的类是抽象类，那么就没必要实现该接口的方法。
【5】ArrayList 和 LinkedList 的区别：
  ArrayList 是 List 接口的一种实现，它是使用数组来实现的。
  LinkedList 是 List 接口的一种实现，它是使用链表来实现的。
  ArrayList 遍历和查找元素比较快。LinkedList 遍历和查找元素比较慢。
  ArrayList 添加、删除元素比较慢。LinkedList 添加、删除元素比较快。
【6】1.采用实现 Runnable、Callable 接口的方式创见多线程时，线程类只是实现了 Runnable 接口或 Callable 接口，
     还可以继承其他类。 线程类.start() -> Runnable.run() or Callable.call()

     2.使用继承 Thread 类的方式创建多线程时，编写简单，如果需要访问当前线程，则无需使用 Thread.currentThread() 方法，
     直接使用 this 即可获得当前线程。
【7】Callable<Object>接口类似于Runnable，从名字就可以看出来了，但是Runnable不会返回结果，并且无法抛出返回结果的异常，
     而Callable<Object>功能更强大一些，被线程执行后，可以返回值，这个返回值可以被Future<Object>拿到，
     也就是说，Future<Object>可以拿到异步执行任务的返回值
【8】
集合框架：
java.util.Collection : 集合层次的根接口
    |--- List: 有序的，可以重复的。
        |--- ArrayList: 采用数组结构存储元素。 查询操作多时选择
        |--- LinkedList: 采用链表结构存储元素。 增删操作多时选择
        |--- Vector:
    |--- Set: 无序的，不允许重复。
        |--- HashSet : 是 Set 接口的典型实现类。
            判断元素是否存在的依据是：先比较 hashCode 值，若 hashCode 存在，再通过 equals() 比较内容
                                     若 hashCode 值不存在，则直接存储

            注意：重写 hashCode 和 equals 二者需要保持一致！
            |--- LinkedHashSet: 相较于 HashSet 多了链表维护元素的顺序。遍历效率高于 HashSet ， 增删效率低于 HashSet
        |--- TreeSet : 拥有自己排序方式
            |-- 自然排序（Comparable）：
                ①需要添加 TreeSet 集合中对象的类实现  Comparable 接口
                ②实现 compareTo(Object o) 方法
            |-- 定制排序（Comparator）
                ①创建一个类实现 Comparator 接口
                ②实现 compare(Object o1, Object o2) 方法
                ③将该实现类的实例作为参数传递给 TreeSet 的构造器  
Map系列集合：
java.util.Map : 用于存储成对对象的集合。具有 key(键)-value(值)对映射关系的集合。
                一个 key 对应着一个 value。 key不允许重复的。
    |--- HashMap：是 Map接口的典型实现类。
        |--- LinkedHashMap: 相较于 HashMap 多了链表维护元素的顺序
    |--- Hashtable： 是线程安全的，因此效率低
        |--- Properties ： 用于操作属性文件
    |--- TreeMap ： 根据 key 拥有自己的排序方式
        |-- 自然排序（Comparable）：
        |-- 定制排序（Comparator）：
【9】自定义泛型类、接口、方法<T>     =>  T : Type   E:Element   K:Key   V:Value
【10】IO流按数据不同：字节流、字符流（字节流操作非文本文件  .jpg  .avi  .rmvb  .mp3     字符流操作文本本件  .txt   .java）
【11】static 和 transient 修饰的属性不能被序列化（ java.io.Serializable）
【12】控制台IO ：
        System.in : “标准”的输入流
        System.out : “标准”的输出流 ---- 通过 System 类中 setOut() 方法可以改变 println() 的默认输出位置
        System.err : “标准”的错误输出流
        
【13】如果一个类继承Thread，则不适合资源共享。但是如果实现了Runable接口的话，则很容易的实现资源共享。
      1.多个线程同时访问同一个对象：对象内的成员变量一定是同步的。对象方法内的局部变量一定是非同步的。
      2.对象的synchronized方法被某个线程执行时，其他线程无法访问该对象的任何synchronized方法（但是可以调用其他非synchronized的方法）。直至该synchronized方法执行完
      3.当调用一个对象的静态synchronized方法时，它锁定的并不是synchronized方法所在的对象，而是synchronized方法所在对象对应的Class对象。
        这样，其他线程就不能调用该类的这个静态方法了，但是可以调用其他的静态方法。
      >>>综合来说一个类的静态方法与普通方法的同步特效是一致的，即synchronized方法的作用域是静态方法同步锁其他静态方法，普通方法同步锁其他普通方法(静态方法与普通方法之间无任何关系)
         synchronized加在方法上作用域不会作用到方法内加了synchronized(){}块的，除非这个同步块是用的synchronized(this){}，这里的this代表此函数不代表类或实例对象
      4.通过使用synchronized同步代码块，锁定一个对象，该对象作为可执行的标志从而达到同步的效果，即所有线程中只有一个线程可以执行这个代码块(其实也就是同步局部变量的访问)
      
      常见线程名词解释：
		主线程：JVM调用程序main()所产生的线程。
		当前线程：这个是容易混淆的概念。一般指通过Thread.currentThread()来获取的进程。
		后台线程：指为其他线程提供服务的线程，也称为守护线程。JVM的垃圾回收线程就是一个后台线程。用户线程和守护线程的区别在于，是否等待主线程依赖于主线程结束而结束
		前台线程：是指接受后台线程服务的线程，其实前台后台线程是联系在一起，就像傀儡和幕后操纵者一样的关系。傀儡是前台线程、幕后操纵者是后台线程。
		由前台线程创建的线程默认也是前台线程。可以通过isDaemon()和setDaemon()方法来判断和设置一个线程是否为后台线程。
		线程类的一些常用方法： 
　　	sleep(): 强迫一个线程睡眠Ｎ毫秒。 
　　	isAlive(): 判断一个线程是否存活。 
　　	join(): 等待线程终止。 
　　	activeCount(): 程序中活跃的线程数。 
　　	enumerate(): 枚举程序中的线程。 
  	  	currentThread(): 得到当前线程。 
　	　	isDaemon(): 一个线程是否为守护线程。 
　		setDaemon(): 设置一个线程为守护线程。(用户线程和守护线程的区别在于，是否等待主线程依赖于主线程结束而结束) 
　		setName(): 为线程设置一个名称。 
　	　	wait(): 强迫一个线程等待。 
　　	notify(): 通知一个线程继续运行。 
　　	setPriority(): 设置一个线程的优先级。
        
        
        