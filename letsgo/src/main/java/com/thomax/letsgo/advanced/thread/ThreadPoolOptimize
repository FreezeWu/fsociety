CPU密集型（CPU-bound） {
    CPU密集型也叫计算密集型，指的是系统的硬盘、内存性能相对CPU要好很多，此时，系统运作大部分的状况是CPU Loading 100%，CPU要读/写I/O(硬盘/内存)，
    I/O在很短的时间就可以完成，而CPU还有许多运算要处理，CPU Loading很高。在多重程序系统中，大部份时间用来做计算、逻辑判断等CPU动作的程序称之CPU bound。
    例如一个计算圆周率至小数点一千位以下的程序，在执行的过程当中绝大部份时间用在三角函数和开根号的计算，便是属于CPU bound的程序。
    CPU bound的程序一般而言CPU占用率相当高。这可能是因为任务本身不太需要访问I/O设备，也可能是因为程序是多线程实现因此屏蔽掉了等待I/O的时间。
}

IO密集型（I/O bound） {
    IO密集型指的是系统的CPU性能相对硬盘、内存要好很多，此时，系统运作，大部分的状况是CPU在等I/O (硬盘/内存) 的读/写操作，此时CPU Loading并不高。
    I/O bound的程序一般在达到性能极限时，CPU占用率仍然较低。这可能是因为任务本身需要大量I/O操作，而pipeline做得不是很好，没有充分利用处理器能力。
    IO密集型任务执行期间，99%的时间都花在IO上，花在CPU上的时间很少。
}


1.计算密集型程序适合C语言多线程，I/O密集型适合脚本语言开发的多线程。
一般说来，大家认为线程池的大小经验值应该这样设置：（其中N为CPU的个数） {
    如果是CPU密集型应用，则线程池大小设置= N + 1
    如果是IO密集型应用，则线程池大小设置= 2N + 1 或 m*N + 1
}


2.对线程池容量调优还需考虑的因素有：内存、文件句柄、套接字句柄、数据库连接等。综合可以得出以下公式 {
    N = number of CPU -> Runtime.getRuntime().availableProcessors(); //可以返回Java虚拟机的可用的处理器数量，此方法会影响性能，不可多次调用
    U = target CPU utilization -> 0<=U<=1; //CPU利用率
    P = ratio of wait time to compute time -> 线程等待时间/线程完成时间;
    所以，线程池的最佳大小= N * U * (1 + P)
}

3.最终，现代CPU的turbo boost会让每个核心的工作达到并行2个线程的效果，比如4核8线程的CPU实际应该可以产生6~7个并行的效果（可以当做可用的处理器数量）


Context switching - times in microseconds - smaller is better (2p/16K => 2个线程并行处理16K的数据量)
-------------------------------------------------------------------------
Host      OS             2p/0K 2p/16K 2p/64K 8p/16K 8p/64K 16p/16K 16p/64K
                         ctxsw  ctxsw  ctxsw ctxsw  ctxsw   ctxsw   ctxsw
--------- ------------- ------ ------ ------ ------ ------ ------- -------
test1     Linux 2.6.21-  10.2   11.4   11.3   14.3   20.9    17.4    26.0
test2     Linux 4.4.0-5  7.630  8.520  10.5   10.9   15.5    10.8    19.0


